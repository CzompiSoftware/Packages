using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CzomPack.SourceGenerator;

[Generator]
public class ExecutableSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new AttributeFinder("Executable"));
    }
    public void Execute(GeneratorExecutionContext context)
    {
        var classes = ((AttributeFinder)context.SyntaxReceiver)?.Classes;

        DiagnosticHelper.ReportDiagnostic(context, DiagnosticSeverity.Info, $"Class '{classes.Count}' found.");
        foreach (var @class in classes)
        {
            //var ns = GetNamespaceFrom(@class);
            //var cl = @class.Identifier.ToString();
            context.AddSource($"{@class.Identifier}.g.cs", GenerateSource(@class));
            //DiagnosticHelper.ReportDiagnostic(context, DiagnosticSeverity.Warning, $"Class '{cl}' found with ToString attribute at '{ns}'", @class);
        }

    }
    public static string GetNamespaceFrom(ClassDeclarationSyntax @class) =>
    @class.Parent switch
    {
        FileScopedNamespaceDeclarationSyntax fileScoped => fileScoped.Name.ToString(),
        NamespaceDeclarationSyntax namespaceDeclaration => namespaceDeclaration.Name.ToString(),
        _ => null
    };
    private string GenerateSource(ClassDeclarationSyntax @class)
    {
        var ns = GetNamespaceFrom(@class);
        // Build up the source code
        return $@" // <auto-generated/>
using System;
using CzomPack.Attributes;
{(string.IsNullOrEmpty(ns) ? "": $"\r\nnamespace {ns};")}

public partial class {@class.Identifier}
{{

    public static void Main(string[] args)
    {{
        Main(Arguments.Parse(args, ""--""));
    }}

    static partial void Main(Arguments args);

}}
";
    }

}
