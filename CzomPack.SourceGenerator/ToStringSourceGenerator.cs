using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace CzomPack.SourceGenerator;

[Generator]
public class ToStringSourceGenerator : ISourceGenerator
{
    public void Initialize(GeneratorInitializationContext context)
    {
        context.RegisterForSyntaxNotifications(() => new ToStringAttributeFinder());
    }
    public void Execute(GeneratorExecutionContext context)
    {
        var classes = ((ToStringAttributeFinder)context.SyntaxReceiver)?.Classes;

        DiagnosticHelper.ReportDiagnostic(context, DiagnosticSeverity.Info, $"Class '{classes.Count}' found.");
        foreach (var @class in classes)
        {
            //var ns = GetNamespaceFrom(@class);
            //var cl = @class.Identifier.ToString();
            context.AddSource($"{@class.Identifier}.g.cs", GenerateSource(@class));
            //DiagnosticHelper.ReportDiagnostic(context, DiagnosticSeverity.Warning, $"Class '{cl}' found with ToString attribute at '{ns}'", @class);
        }

    }
    public static string GetNamespaceFrom(ClassDeclarationSyntax @class) =>
    @class.Parent switch
    {
        FileScopedNamespaceDeclarationSyntax fileScoped => fileScoped.Name.ToString(),
        NamespaceDeclarationSyntax namespaceDeclaration => namespaceDeclaration.Name.ToString(),
        _ => null
    };
    private string GenerateSource(ClassDeclarationSyntax @class)
    {
        var ns = GetNamespaceFrom(@class);
        // Build up the source code
        return $@" // <auto-generated/>
using System;
{(string.IsNullOrEmpty(ns) ? "": $"\r\nnamespace {ns};")}

public partial class {@class.Identifier}
{{
    // <auto-generated/>
    public override string ToString()
    {{
        Type t = GetType();
        return $""{{t.Name}}{{{{{{string.Join("", "", t.GetProperties().Select(p => $""{{p.Name}}={{p.GetValue(this)}}""))}}}}}}"";
    }}
}}
";
    }

}
